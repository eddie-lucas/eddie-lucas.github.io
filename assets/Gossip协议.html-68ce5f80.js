import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,d as o}from"./app-d83e1369.js";const r={};function l(t,s){return e(),a("div",null,s[0]||(s[0]=[o('<h2 id="什么是gossip协议" tabindex="-1"><a class="header-anchor" href="#什么是gossip协议" aria-hidden="true">#</a> 什么是Gossip协议？</h2><p>Gossip协议是一个通信协议，在redis集群中，各个节点间的通信基于Gossip协议</p><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议</p><h2 id="gossip在redis集群中的作用" tabindex="-1"><a class="header-anchor" href="#gossip在redis集群中的作用" aria-hidden="true">#</a> Gossip在redis集群中的作用</h2><p>在redis集群中，需要提供维护节点元数据信息的机制，所谓<strong>元数据是指节点负责哪些数据、主从属性、是否出现故障等状态信息</strong>。常见的元数据维护方式分为集中式和无中心式。Redis Cluster 采用 Gossip 协议实现了无中心式。</p><p>Redis Cluster 中使用 Gossip 主要有两大作用：</p><ul><li>去中心化，以实现分布式和弹性扩展；</li><li>失败检测，以实现高可用</li></ul><h2 id="gossip原理图解" tabindex="-1"><a class="header-anchor" href="#gossip原理图解" aria-hidden="true">#</a> Gossip原理图解</h2><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/20241226164934.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图中的20表示一共有20个节点，4表示某个节点在进行传播的时候，都会向4个目标节点进行传，现在从一个源节点出发（红色），连线表示与该源节点正常连接的节点，较粗的线表示其传播的目标节点</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/20241226165437.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一次消息完成传播后，新增了4个节点会被“感染”，即这4个节点也收到了消息。这时候，总计有5个节点变成红色</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/20241226170427.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那么在下一次传播周期时，总计有5个节点，且这5个节点每个节点都会向4个节点传播消息。最后，20个节点全部被感染（都变成红色节点），即说明需要传播的消息已经传播给了所有节点</p><h2 id="gossip的优点" tabindex="-1"><a class="header-anchor" href="#gossip的优点" aria-hidden="true">#</a> Gossip的优点</h2><ul><li><strong>扩展性</strong>：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致</li><li><strong>容错</strong>：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性</li><li><strong>去中心化</strong>：Gossip 协议不要求任何中心节点，所有节点都可以是平等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网</li><li><strong>高效</strong>：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内达到一致。消息传播速度达到了 logN</li></ul><h2 id="gossip的缺点" tabindex="-1"><a class="header-anchor" href="#gossip的缺点" aria-hidden="true">#</a> Gossip的缺点</h2><ul><li><strong>消息延迟</strong>：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下</li><li><strong>消息冗余</strong>：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余</li></ul><h2 id="gossip-传播类型" tabindex="-1"><a class="header-anchor" href="#gossip-传播类型" aria-hidden="true">#</a> <strong>Gossip 传播类型</strong></h2><p>Gossip 有两种传播类型：</p><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li></ul><h2 id="gossip-中的通信模式" tabindex="-1"><a class="header-anchor" href="#gossip-中的通信模式" aria-hidden="true">#</a> <strong>Gossip 中的通信模式</strong></h2><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式：</p><ul><li>Push：节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，<strong>Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次</strong>。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的</p>',25)]))}const g=i(r,[["render",l],["__file","Gossip协议.html.vue"]]);export{g as default};
